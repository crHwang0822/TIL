# 2.3 라이브러리와 프로젝트 구조

- JPA  구현체로 하이버네이트를 사용하기 위한 핵심 라이브러리 소개
    - `hibernate-core`: 하이버네이트 라이브러리
    - `hibernate-entitymanager`: 하이버네이트가 JPA 구현체로 동작하도록 JPA 표준을 구현한 라이브러리
    - `hibernate-jpa-2.1-api`: JPA 2.1 표준 API를 모아둔 라이브러리

## 1️⃣ 메이븐과 사용 라이브러리 관리

- 메이븐
    - 라이브러리를 관리해주는 도구
    - pom.xml에 사용할 라이브러리를 적으면 라이브러리를 자동으로 내려받아서 관리해준다.
    - 크게 라이브러리 관리 기능과 빌드 기능 제공
        - 라이브러리 관리 기능: 사용할 라이브러리의 이름과 버전을 명시하면 라이브러리를 자동으로 내려받고 관리해줌
        - 빌드 기능: 애플리케이션을 빌드하는 표준화된 방법 제공

# 2.4 객체 매핑 시작

- JPA는 매핑 어노테이션을 분석해서 어떤 객체가 어떤 테이블과 관계가 있는지 알아냄
- `@Entity` : 이 클래스를 테이블과 매핑한다고 JPA에게 알려주는 역할. 이 어노테이션이 사용된 클래스를 엔티티 클래스라고 한다.
- `@Table` : 엔티티 클래스에 매핑할 테이블 정보를 알려주는 역할. 이 어노테이션을 생략하면 클래스 이름 (정확히는 엔티티 이름)을 테이블 이름으로 매핑한다.
- `@Id` : 엔티티 클래스의 필드를 테이블의 기본 키로 매핑하는 역할. 이 어노테이션이 사용된 필드를 식별자 필드라고 한다.
- `@Column` : 필드를 컬럼에 매핑하는 역할
- `매핑 정보가 없는 필드` : 매핑 어노테이션을 생략할 경우 필드명을 사용해서 컬럼명으로 매핑한다.

# 2.5 persistence.xml 설정

- **JPA는 persistence.xml 을 사용해서 필요한 설정 정보를 관리**함.
- 설정 파일이 `META-INF/persistence.xml` 경로에 존재할 경우 별도의 설정 없이 JPA가 인식 가능
- 내용 분석
    - **`<persistence-unit name="jpabook">`**<br>
      : JPA 설정은 영속성 유닛 (persistence-unit)이라는 것부터 시작하는데,<br>   일반적으로 연결할 데이터베이스당 하나의 영속성 유닛을 등록한다.
      : 영속성 유닛에는 고유한 이름을 부여해야 하는데, 위 코드에서는 jpabook이라는 이름을 사용중
      - **JPA 표준 속성**<br>
      `javax.persistence` 로 시작하는 속성은 JPA 표준 속성으로 특정 구현체에 종속되지 않음
      - **하이버네이트 속성**<br>
      `hibernate` 로 시작하는 속성은 하이버네이트 전용 속성이므로 하이버네이트에서만 사용 가능<br>
      `show_sql` : 하이버네이트가 실행한 SQL 출력<br>
      `format_sql` : 하이버네이트가 실행한 SQL을 출력할 때 보기 쉽게 정렬<br>
      `use_sql_comments` : 쿼리를 출력할 때 주석도 함께 출력<br>
      `id.new_generator_mappings` : JPA 표준에 맞춘 새로운 키 생성 전략 사용<br>

## 1️⃣ 데이터베이스 방언

- **방언**: SQL 표준을 지키지 않거나 특정 데이터베이스만의 고유한 기능<br>
  ex. 가변 문자 타입으로 MySQL은 VARCHAR, 오라클은 VARCHAR2 사용
- 개발자가 특정 데이터베이스에 종속되는 기능을 많이 사용할 경우 데이터베이스 교체가 어려워짐<br>
  **⇒ JPA 구현체들은 이러한 문제를 해결하기 위해 다양한 데이터베이스 방언 클래스 제공**
  <img src = "https://github.com/user-attachments/assets/d61026ae-c01d-48fc-b073-78dbd45f6673" width="70%"><br>
> 개발자 : JPA가 제공하는 표준 문법에 맞추어 JPA 사용 <br>
> 방언 : 특정 데이터베이스에 의존적인 SQL을 처리해줌   <br>
**⇒ 데이터베이스가 교체될 경우 코드를 변경할 필요 없이 방언만 교체해주면 된다!**


- 하이버네이트에서 제공하는 데이터베이스 방언
    - H2 : org.hibernate.dialect.H2Dialect
    - 오라클 : org.hibernate.dialect.Oracle10gDialect
    - MySQL : org.hibernate.dialect.MySQL5InnoDBDialect

# 2.6 애플리케이션 개발

## 1️⃣ 엔티티 매니저 설정

### 엔티티 매니저 팩토리 생성
- `EntityManagerFactory emf = Persistence.*createEntityManagerFactory*("jpabook");`<br>
-  META-INF/persistence.xml 에서 이름이 jpabook인 영속성 유닛을 찾아서 엔티티 매니저 팩토리를 생성한다.
- 이때 JPA를 동작시키기 위한 기반 객체를 만들고 (JPA 구현체에 따라서는) 데이터베이스 커넥션 풀을 생성하므로 엔티티 매니저 팩토리를 생성하는 비용 ↑↑ → **애플리케이션 전체에서 딱 한번만 생성하고 공유해서 사용**해야 함<br>
### 엔티티 매니저 생성
- `EntityManager em = emf.createEntityManager();`<br>
- **JPA의 기능 대부분은 엔티티 매니저가 제공** (엔티티 매니저를 사용해서 엔티티의 CRUD 가능) <br>
- 엔티티 매니저는 내부에 데이터소스 (데이터베이스 커넥션)을 유지하면서 **데이터베이스와 통신**하므로 개발자는 엔티티 매니저를 가상의 데이터베이스로 생각할 수 있다. <br>
- **엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드 간에 공유하거나 재사용 X**<br>
### 종료
- 사용이 끝난 엔티티 매니저는 반드시 종료<br>
- 애플리케이션을 종료할 때 엔티티 매니저 팩토리도 반드시 종료<br>

## 2️⃣ 트랜잭션 관리

- 엔티티 매니저에서 트랜잭션 API를 받아와서 트랜잭션을 시작
- JPA를 사용하면 항상 트랜잭션 안에서 데이터를 변경해야 함 (안 그러면 예외 발생)

## 3️⃣ 비즈니스 로직

- **등록, 수정, 삭제, 조회 작업이 엔티티 매니저(em)을 통해 수행**되는 것을 확인 가능
- `등록`: em.persiste() 메소드에 저장할 엔티티를 넘김 → JPA는 매핑 정보를 분석한 후 SQL을 생성해 데이터베이스에 전달
- `수정`: 엔티티의 setter를 사용해 값을 변경 → JPA는 어떤 엔티티가 변경되었는지 추적하는 기능을 갖고 있으므로, UPDATE SQL을 생성해 실행
- `삭제`: em.remove() 메소드에 삭제할 엔티티를 넘김 → JPA는 DELETE SQL을 생성해 실행
- `한 건 조회`: em.find() 메소드에 조회할 엔티티 타입과 식별자 값을 넘김 → JPA는 SELECT SQL을 생성해 데이터베이스에서 조회 및 결과 값으로 엔티티를 생성해 반환

## 4️⃣ JPQL

- 이때까지 등록,수정,삭제,한 건 조회의 경우 SQL 전혀 사용 X. 엔티티 객체를 중심으로 개발함
- 그러나 검색 쿼리의 경우, 엔티티 객체를 대상으로 검색하려면 데이터베이스의 모든 데이터를 불러와서 엔티티 객체로 변경한 다음 검색해야 함 → 사실상 불가능한 일
- 결국, 검색 조건이 포함된 SQL을 이용하여 필요한 데이터만 데이터베이스에서 불러온 후, 엔티티 객체로 변경해야 함 <br>
  ⇒ JPA는 이를 JPQL이라는 쿼리 언어로 해결
### JPQL: SQL을 추상화한 객체지향 쿼리 언어
| JPQL | **엔티티 객체를 대상으로 쿼리한다.** |
  | --- | --- |
| SQL | 데이터베이스 테이블을 대상으로 쿼리한다. |
### JPQL 사용법
1. em.createQuery(JPQL , 반환타입) 메소드를 실행해 쿼리 객체 생성
2.  쿼리 객체의 getResultList()m 메소드 호출
3. JPA는 JPQL을 분석하여 적절한 SQL을 만들어 데이터베이스에서 데이터를 조회한다.<br>
   `List<Member> members = em.createQuery("select m from Member m", Member.class).getResultList();`

### ❔ 그래서 JPQL 을 왜 사용하는 건데?

1. **객체 지향적 접근** <br>
   a. **엔티티 중심의 쿼리**가 가능해진다. 데이터베이스 구조를 직접 다루지 않아도 됨<br>
   b. 연관된 엔티티를 자연스럽게 조회 가능함. <br>
   → `SELECT u FROM User u JOIN u.orders o WHERE o.status = :status`<br>
2. **데이터베이스 독립성**<br>
   JPQL을 사용하면 특정 데이터베이스에 의존하지 않으므로, <br>
   데이터베이스를 변경할 때 애플리케이션에서 쿼리를 수정할 필요가 거의 없음<br>
3. 이외에도 동적 쿼리 작성 용이 … 등등 이 있음

# 2.7 정리

- 개발환경 셋팅
- JPA 를 사용해 객체 하나를 테이블에 CRUD 하는 간단한 애플리케이션 작성