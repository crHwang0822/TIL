## 1.1 SQL을 직접 다룰 때 발생하는 문제점


### 1️⃣ 반복, 반복 그리고 반복

- 회원을 CRUD 하는 기능을 개발하기 위한 순서
    1. 회원 객체 생성
    2. 회원 객체를 데이터베이스에 관리할 목적으로 회원용 DAO (데이터 접근 객체) 생성
    3. SQL을 작성하고 JDBC API를 사용하는 비슷한 일이 반복됨
        1. 조회 : 조회용 SQL 작성 → JDBC API 를 사용해서 SQL 실행 → 조회 결과를 Member 객체로 매핑
        2. 생성 : 등록용 SQL 작성 → 회원 객체의 값을 꺼내서 등록 SQL 에 전달 → JDBC API를 사용해서 SQL 실행
- 회원 객체를 데이터베이스가 아닌 자바 컬렉션에 보관한다면 ⇒ 코드 한 줄로 객체 저장 가능 (`list.add(member);`)    
  - but 데이터베이스는 데이터 중심의 구조를 가지므로 객체를 데이터베이스에 직접 저장하거나 조회할 수 없고, 개발자가 객체지향 애플리케이션과 데이터베이스 중간에서 변환 작업을 해주어야 함
  - 객체를 데이터베이스에 CRUD 하기 위해서는 너무 많은 SQL과 JDBC API를 코드로 작성해야 하며, 테이블마다 비슷한 일을 반복해야 함. DAO 의 개발은 지루하다!

### 2️⃣ SQL 에 의존적인 개발

- if 갑자기 회원의 연락처도 함께 저장해달라는 요구사항이 추가된다면 ⇒ 매핑 코드 및 SQL 수정 필요!
- if 갑자기 회원은 어떤 한 팀에 필수로 소속되어야 한다는 요구사항이 추가된다면
    - Member 객체가 연관된 Team 객체를 사용할 수 있을지 없을지는 전적으로 사용하는 SQL 에 달려있음 → DAO를 이용해서 SQL을 숨겨도 결국은 SQL을 직접 열어 확인해봐야 함. → 개발자들이 엔티티를 신뢰하고 사용할 수 없음
- **애플리케이션에서 SQL을 직접 다룰 때 발생하는 문제점**
    - 진정한 의미의 계층 분할이 어려움 (물리적으로는 SQL과 JDBC API를 데이터 접근 계층에 숨기는 데 성공했을 수 있지만 논리적으로 엔티티와 강한 의존관계를 가짐)
    - 엔티티를 신뢰할 수 없음
    - SQL에 의존적인 개발을 피하기 힘듦

### 3️⃣ JPA와 문제 해결

- 개발자는 직접 SQL 을 작성하지 않고 JPA 가 제공하는 API를 사용 → JPA 는 개발자 대신 적절한 SQL 을 생성해서 데이터베이스에 전달
- JPA 가 제공하는 CRUD API
  - 저장 기능 : `jpa.persist(member);`
  - 조회 기능 : `jpa.find(Member.class,memberId);`
  - 수정 기능 : 별도의 메서드 제공 X
  - 연관된 객체 조회 : 지연 로딩 사용
    `Member mem = jpa.find(Member.class,memberId);`
    `Team team = mem.getTeam();`

## 1.2 패러다임의 불일치

- 객체 : 속성(필드)와 기능(메서드)를 가짐
    - 객체가 부모 객체를 상속받았거나 다른 객체를 참조하고 있다면 객체의 상태를 저장하기 쉽지 않음
    - 관계형 데이터베이스는 데이터 중심으로 구조화되어 있기 때문에 객체를 저장하는 데 한계가 있음
- **패러다임 불일치 문제**
  : 객체와 관계형 데이터베이스가 지향하는 목적이 서로 달라 둘의 기능과 표현 방법이 다른 문제

### 1️⃣ 상속

- 객체 VS 테이블
    - 객체는 상속이라는 기능을 가짐
    - 테이블은 상속 기능 X.
    - 데이터베이스 모델링에서 이야기하는 슈퍼타입 서브타입 관계를 사용하면 객체 상속과 유사한 형태로 테이블 설계 가능
> JPA 와 상속 <br>
    - 개발자 : 자바 컬렉션에 객체를 저장하듯 persist() 메서드를 사용해 JPA 에 객체 저장 → <br>
    `jpa.persist(album);`<br>
    - JPA : 상속과 관련된 패러다임 불일치 문제를 개발자 대신 해결 → <br>
    `(예) Item 을 상속하는 Album 객체를 저장하기 위해 이 객체를 분해해 ITEM 테이블과 ALBUM 테이블에 각각 데이터를 삽입하는 두 개의 SQL 생성하는 일을 대신 해줌`<br>

### 2️⃣ 연관관계

- 객체 VS 테이블
    - 객체는 참조를 사용해 다른 객체와 연관관계를 가지며 참조에 접근해서 연관된 객체 조회
    - 테이블은 외래 키를 사용해서 다른 테이블과 연관 관계를 가지고 조인을 사용해서 연관된 테이블 조회
    - 객체는 참조가 있는 방향으로만 조회가 가능하지만, 테이블은 외래 키 하나로 모두 가능
    - 객체 모델은 외래 키가 필요 없고 참조만 있으면 되는 반면 테이블은 참조가 필요 없고 외래 키만 있으면 됨   
      → 개발자가 중간에서 변환 역할을 해주어야 한다.
> JPA 와 연관관계 <br>
    - 개발자 : 회원과 팀의 관계를 설정하고 persist() 를 사용해 회원 객체 저장 → <br>
        `member.setTeam(team); //회원과 팀 연관관계 설정`<br>
        `jpa.persist(member); //회원과 연관관계를 함께 저장` <br>
    - JPA : 연관관계와 관련된 패러다임의 불일치 문제를 해결 → <br>
    `(예) team 의 참조를 외래 키로 변환해서 적절한 INSERT SQL 을 데이터베이스에 전달하며, 객체를 조회할 때 외래 키를 참조로 변환하는 일도 처리`

### 3️⃣ 객체 그래프 탐색

- 객체 그래프 탐색 : 참조를 사용해서 연관관계 탐색
    - 객체 그래프를 탐색하는 코드 예시
      `member.getOrder().getOrderItem()`
- SQL 을 직접 다루는 경우 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다. → 어디까지 객체 그래프 탐색이 가능한지 알아보기 위해서는 데이터 접근 계층인 DAO 를 열어서 SQL 을 직접 확인해야 한다.
    - 엔티티가 SQL 에 논리적으로 종속되어 발생하는 문제
    - MemberDAO 에 회원을 조회하는 메서드를 상황에 따라 여러 개 만들어 사용해야 함    
      → `getMember()` / `getMemberWithTeam()` / `getMemberWithOrderWithTeam()`
> JPA 와 객체 그래프 탐색 <br>
    - JPA 를 사용하면 객체 그래프를 마음껏 탐색 가능<br>
    - JPA : 연관된 객체를 사용하는 시점에 적절한 SELECT SQL 실행 (**지연 로딩**) → 연관된 객체를 신뢰하고 사용할 수 있음<br>
    
-  **지연 로딩**      
    - **실제 객체를 사용하는 시점까지 데이터베이스 조회를 미루는 것**   
    - 예를 들어, 엔티티 A가 엔티티 B와 연관되어 있을 때, A를 조회할 때  B를 즉시 로드하는 것이 아니라 B가 실제로 필요할 때 로딩하는 것    
    - JPA 는 지연 로딩을 투명하게 처리 → 개발자가 엔티티를 사용하면서 언제 지연 로딩이 일어나는지 명확히 알 필요가 없게 만들어줌. 개발자는 따로 관련 코드를 작성하지 않고서 평소처럼 객체를 사용하기만 하면 되고 내부에서 언제 데이터가 로드될지는 JPA가 알아서 처리     
    - JPA 는 연관된 객체를 즉시 함께 조회할지 아니면 실제 사용되는 시점에 지연해서 조회할지에 대해 간단한 설정으로 정의 가능    

### 4️⃣ 비교

- 객체 VS 테이블
    - 테이블 : 기본 키(PK)의 값으로 행 구분
    - 객체 : 동일성 비교와 동등성 비교, 두 가지 방법 존재
        - 동일성 비교 : == 비교, 객체 인스턴스의 주소 값을 비교
        - 동등성 비교 : equal() 메서드를 사용해서 객체 내부의 값 비교
    - 예시
        ```java
        class MemberDAO {
        	public Member getMember(String memberId) {
        		String sql = "SELECT * FROM MEMBER WHERE MEMBER_ID = ?";
        		...
        		return new Member(...); //인스턴스 새로 생성해서 반환
        	}
        }
        ```
        ```java
        String memberId = "100";
        Member member1 = memberDAO.getMember(memberId);
        Member member2 = memberDAO.getMember(memberId);
        
        member1 == member2; //false 반환
        ```
        ```java
        Member member1 = list.get(0);
        Memebr member2 = list.get(0);
        
        member1 == member2 //true 반환
        ```
  
> JPA 와 비교<br>
    - JPA : 같은 트랜잭션일 때 같은 **객체**가 조회되는 것 보장 → <br>
        `String memberId = "100";`<br>
        `Member member1 = jpa.find(Member.class, memberId);`<br>
        `Member member2 = jpa.find(Member.class, memberId);`<br>
        `member1 == member2; //true 반환`<br>
        
### 5️⃣ 정리

정교하게 객체 모델링을 할수록 객체와 관계형 데이터베이스 간 패러다임 불일치 문제는 커지고, 이를 극복하기 위해 개발자가 소모하는 비용도 커진다.
JPA는 패러다임의 불일치 문제를 해결하고 정교한 객체 모델링을 유지하도록 도와준다.

## 1.3 JPA란 무엇인가?

- **JPA** (Java Persistence API) : **자바 진영의 ORM 기술 표준**, **애플리케이션과 JDBC 사이**에서 동작      
  <img src ="https://github.com/user-attachments/assets/657ea3f2-6969-41b5-9675-e0e6322b3e00" width = "70%">
- **ORM** (Object-Relational Mapping) : 객체와 관계형 데이터베이스를 매핑
    - **ORM 프레임워크**는 개발자 대신 SQL 을 생성해서 데이터베이스에 전달해줄 뿐만 아니라 다양한 패러다임의 불일치 문제를 해결    
      <img src ="https://github.com/user-attachments/assets/92906f5a-e002-4fe7-976b-4e1a8fac2032" width = "70%"><br>   
      > 개발자가 객체를 자바 컬렉션에 저장하듯 ORM 프레임워크에 저장하면 ORM 프레임워크는 적절한 SQL 을 생성해서 데이터베이스에 객체를 저장해줌
      
      <img src ="https://github.com/user-attachments/assets/d045e8e7-fea1-42db-9075-7ccea8144c7e" width = "70%"><br>
      > 개발자는 JPA (ORM 프레임워크) 를 통해서 객체를 직접 조회하는 것도 가능     
    - 자바 진영에는 다양한 ORM 프레임워크가 존재하고, 하이버네이트 프레임워크를 가장 많이 사용

### 1️⃣ JPA 소개

- 엔터프라이즈 자바 빈즈 (EJB)
    - 과거 자바 진영이 만든 기술 표준으로, 엔티티 빈이라는 ORM 기술 표준도 포함되어 있음
    - 복잡도 ↑ 기술 성숙도↓
    - 자바 엔터프라이즈 (J2EE) 애플리케이션 서버에서만 동작
- 하이버네이트 (hibernate.org) 등장
    - 오픈소스 ORM 프레임워크
    - EJB 의 ORM 기술보다 상대적으로 가볍고 실용적이며 기술 성숙도가 높았음
    - 자바 엔터프라이즈 애플리케이션 서버 없이도 동작
- **JPA**
    - EJB 3.0 에서 하이버네이트를 기반으로 새로 만든 자바 ORM 기술 표준
    - **자바 ORM 기술에 대한 API 표준 명세**로, 인터페이스를 모아둔 것
        - JPA 자체는 인터페이스이므로 직접적인 동작을 수행하지 않음
    - JPA 를 사용하기 위해서는 JPA 를 구현한 ORM 프레임워크를 선택해야 함
        - Hibernate/EclipseLink/DataNucleus 등이 존재하며 Hibernate 가 대중적
        - 이들은 JPA의 인터페이스를 구현하여 실제 데이터베이스와의 상호작용 처리
    - JPA 라는 표준 덕분에 특정 구현 기술에 대한 의존도를 줄일 수 있고, 다른 구현 기술로 손쉽게 이동할 수 있음
        - JPA가 인터페이스를 통해 구현체를 추상화하기 때문에 비즈니스 로직은 JPA 표준 API만을 사용하고, 특정 구현체에 대한 종속성을 최소화함
- JPA 버전별 특징
    - 1.0 (JSR 220) 2006년 : 초기 버전으로 복합 키와 연관관계 기능 부족
    - 2.0 (JSR 317) 2009년 : 대부분의 ORM 기능 포함, JPA Criteria 추가
    - 3.0 (JSR 338) 2013년 : 스토어트 프로시저 접근, 컨버터, 엔티티 그래프 기능 추가

### 2️⃣ 왜 JPA 를 사용해야 하는가?

- **생산성**
    - 개발자가 반복적인 코드와 SQL을 직접 작성할 필요 없이 자바 컬렉션에 객체를 저장하듯 JPA에게 저장할 객체를 전달하면, JPA 가 알아서 처리해줌
    - DDL 문을 자동으로 생성해주는 기능 존재
      → 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전
- **유지보수**
    - SQL 을 직접 다룰 시 엔티티에 필드를 하나만 추가하더라도 수정할 코드 ↑
    - 개발자가 작성해야 했던 SQL문과 JDBC API 코드를 JPA가 대신 처리해주므로 유지보수해야 하는 코드의 양 ↓
    - JPA가 패러다임 불일치 문제를 해결해주므로 유지보수하기 좋은 도메인 모델 설계 가능성 ↑
- **패러다임 불일치 해결**
    - 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임의 불일치 문제 해결
- **성능**
    - JPA는 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회 제공
    - 같은 트랜잭션 안에서 같은 회원을 두 번 조회하는 코드 → JPA 를 사용하면 SELECT 쿼리를 데이터베이스에 한 번만 전달하고 두 번째는 조회한 회원 객체를 재사용한다.
    - 하이버네이트는 SQL 힌트를 넣을 수 있는 기능 제공
        - 힌트 : 속도 개선 등의 목적으로 ***SQL*** 튜닝 시 사용되는 지시 구문
- **데이터 접근 추상화와 벤더 독립성**
    - JPA가 없다면 애플리케이션은 처음 선택한 DB 기술에 종속되고 다른 DB로 변경하기 어려움
    - JPA는 애플리케이션과 DB 사이 추상화된 데이터 접근 계층을 제공해서 애플리케이션이 특정 DB 기술에 종속되지 않도록 함 → DB 변경시 JPA에게 알려주기만 하면 됨
        - 로컬 개발환경은 H2 DB를 사용하고 상용 환경은 MySQL DB를 사용하는 것이 가능해짐
    <img src ="https://github.com/user-attachments/assets/432a5437-a8d8-476e-98e1-63f9171ddcff" width = "70%"><br>
- **표준**
    - JPA는 자바 진영의 ORM 기술 표준이므로 표준을 사용하면 구현 기술로 손쉽게 변경 가능

## 1.4 정리

- SQL 을 직접 다룰 때 발생하는 문제점
- 객체지향 언어와 관계형 데이터베이스 사이의 패러다임 불일치 문제
- JPA가 패러다임 불일치 문제를 해결하는 방법
- JPA 소개 및 JPA를 사용해야하는 이유 (장점)
